<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArXivFetcher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JabRef</a> &gt; <a href="index.source.html" class="el_package">org.jabref.logic.importer.fetcher</a> &gt; <span class="el_source">ArXivFetcher.java</span></div><h1>ArXivFetcher.java</h1><pre class="source lang-java linenums">package org.jabref.logic.importer.fetcher;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.jabref.logic.cleanup.EprintCleanup;
import org.jabref.logic.help.HelpFile;
import org.jabref.logic.importer.FetcherException;
import org.jabref.logic.importer.FulltextFetcher;
import org.jabref.logic.importer.IdBasedFetcher;
import org.jabref.logic.importer.IdFetcher;
import org.jabref.logic.importer.ImportFormatPreferences;
import org.jabref.logic.importer.PagedSearchBasedFetcher;
import org.jabref.logic.importer.fetcher.transformers.ArXivQueryTransformer;
import org.jabref.logic.util.io.XMLUtil;
import org.jabref.logic.util.strings.StringSimilarity;
import org.jabref.model.entry.BibEntry;
import org.jabref.model.entry.KeywordList;
import org.jabref.model.entry.LinkedFile;
import org.jabref.model.entry.field.Field;
import org.jabref.model.entry.field.InternalField;
import org.jabref.model.entry.field.StandardField;
import org.jabref.model.entry.identifier.ArXivIdentifier;
import org.jabref.model.entry.identifier.DOI;
import org.jabref.model.entry.types.StandardEntryType;
import org.jabref.model.paging.Page;
import org.jabref.model.strings.StringUtil;
import org.jabref.model.util.OptionalUtil;

import org.apache.http.client.utils.URIBuilder;
import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

/**
 * Fetcher for ArXiv that merges fields from arXiv-issued DOIs (and user-issued ones when applicable) to get more information overall.
 * &lt;p&gt;
 * These are the post-processing steps applied to the original fetch from ArXiv's API:
 * &lt;ol&gt;
 *     &lt;li&gt;Use ArXiv-issued DOI to get more merge more data with original entry, overwriting some of those fields;&lt;/li&gt;
 *     &lt;li&gt;Use user-issued DOI (if it was provided) to merge even more data with the result of the previous step, overwriting some of those fields;&lt;/li&gt;
 *     &lt;li&gt;Modify keywords: remove repetitions and adapt some edge cases (commas in keyword transformed into forward slashes).&lt;/li&gt;
 * &lt;/ol&gt;
 *
 * @see &lt;a href=&quot;https://blog.arxiv.org/2022/02/17/new-arxiv-articles-are-now-automatically-assigned-dois/&quot;&gt;arXiv.org blog &lt;/a&gt; for more info about arXiv-issued DOIs
 * @see &lt;a href=&quot;https://arxiv.org/help/api/index&quot;&gt;ArXiv API&lt;/a&gt; for an overview of the API
 * @see &lt;a href=&quot;https://arxiv.org/help/api/user-manual#_calling_the_api&quot;&gt;ArXiv API User's Manual&lt;/a&gt; for a detailed description on how to use the API
 */
public class ArXivFetcher implements FulltextFetcher, PagedSearchBasedFetcher, IdBasedFetcher, IdFetcher&lt;ArXivIdentifier&gt; {

<span class="fc" id="L74">    private static final Logger LOGGER = LoggerFactory.getLogger(ArXivFetcher.class);</span>

    // See https://blog.arxiv.org/2022/02/17/new-arxiv-articles-are-now-automatically-assigned-dois/
    private static final String DOI_PREFIX = &quot;10.48550/arXiv.&quot;;

    /*
     * Reason behind choice of these fields:
     *   - KEYWORDS: More descriptive
     *   - AUTHOR: Better formatted (last name, rest of name)
     */
<span class="fc" id="L84">    private static final Set&lt;Field&gt; CHOSEN_AUTOMATIC_DOI_FIELDS = Set.of(StandardField.KEYWORDS, StandardField.AUTHOR);</span>

    /*
     * Reason behind choice of these fields:
     *   - DOI: give preference to DOIs manually inputted by users, instead of automatic ones
     *   - PUBLISHER: ArXiv-issued DOIs give 'ArXiv' as entry publisher. While this can be true, prefer using one from external sources,
     *      if applicable
     *   - KEY_FIELD: Usually, the KEY_FIELD retrieved from user-assigned DOIs are 'nicer' (instead of a DOI link, it's usually contains one author and the year)
     */
<span class="fc" id="L93">    private static final Set&lt;Field&gt; CHOSEN_MANUAL_DOI_FIELDS = Set.of(StandardField.DOI, StandardField.PUBLISHER, InternalField.KEY_FIELD);</span>

<span class="fc" id="L95">    private static final Map&lt;String, String&gt; ARXIV_KEYWORDS_WITH_COMMA_REPLACEMENTS = Collections.unmodifiableMap(Map.of(</span>
            &quot;Computational Engineering, Finance, and Science&quot;, &quot;Computational Engineering / Finance / Science&quot;,
            &quot;Distributed, Parallel, and Cluster Computing&quot;, &quot;Distributed / Parallel / Cluster Computing&quot;));

    private final ArXiv arXiv;
    private final DoiFetcher doiFetcher;
    private final ImportFormatPreferences importFormatPreferences;

    public ArXivFetcher(ImportFormatPreferences importFormatPreferences) {
<span class="fc" id="L104">        this(importFormatPreferences, new DoiFetcher(importFormatPreferences));</span>
<span class="fc" id="L105">    }</span>

    /**
     * @param doiFetcher The fetcher, maybe be NULL if no additional search is desired.
     */
<span class="fc" id="L110">    public ArXivFetcher(ImportFormatPreferences importFormatPreferences, DoiFetcher doiFetcher) {</span>
<span class="fc" id="L111">        this.arXiv = new ArXiv(importFormatPreferences);</span>
<span class="fc" id="L112">        this.doiFetcher = doiFetcher;</span>
<span class="fc" id="L113">        this.importFormatPreferences = importFormatPreferences;</span>
<span class="fc" id="L114">    }</span>

    @Override
    public Optional&lt;URL&gt; findFullText(BibEntry entry) throws IOException {
<span class="fc" id="L118">        return arXiv.findFullText(entry);</span>
    }

    @Override
    public TrustLevel getTrustLevel() {
<span class="fc" id="L123">        return arXiv.getTrustLevel();</span>
    }

    @Override
    public String getName() {
<span class="fc" id="L128">        return arXiv.getName();</span>
    }

    @Override
    public Optional&lt;HelpFile&gt; getHelpPage() {
<span class="nc" id="L133">        return arXiv.getHelpPage();</span>
    }

    /**
     * Remove duplicate values on &quot;KEYWORD&quot; field, if any. Al
     *
     * @param bibEntry A BibEntry to modify
     */
    private void adaptKeywordsFrom(BibEntry bibEntry) {
<span class="fc" id="L142">        Optional&lt;String&gt; allKeywords = bibEntry.getField(StandardField.KEYWORDS);</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (allKeywords.isPresent()) {</span>
            // With the use of ArXiv-issued DOI's KEYWORDS field, some of those keywords might contain comma. As this is the
            // default keyword separator, replace the commas of these instances with some other character
            // (see ARXIV_KEYWORDS_WITH_COMMA_REPLACEMENTS variable)
<span class="fc bfc" id="L147" title="All 2 branches covered.">            for (Map.Entry&lt;String, String&gt; entry : ARXIV_KEYWORDS_WITH_COMMA_REPLACEMENTS.entrySet()) {</span>
<span class="fc" id="L148">                allKeywords = Optional.of(allKeywords.get().replaceAll(entry.getKey(), entry.getValue()));</span>
<span class="fc" id="L149">            }</span>

<span class="fc" id="L151">            String filteredKeywords = KeywordList.merge(</span>
<span class="fc" id="L152">                    allKeywords.get(),</span>
                    &quot;&quot;,
<span class="fc" id="L154">                    importFormatPreferences.bibEntryPreferences().getKeywordSeparator()).toString();</span>
<span class="fc" id="L155">            bibEntry.setField(StandardField.KEYWORDS, filteredKeywords);</span>
        }
<span class="fc" id="L157">    }</span>

    /**
     * Get ArXiv-issued DOI from the entry's arXiv ID
     * &lt;br/&gt;&lt;br/&gt;
     * ArXiv-issued DOIs are identifiers associated with every ArXiv entry. They are composed of a fixed
     * {@link #DOI_PREFIX} + the entry's ArXiv ID
     *
     * @param arXivId An ArXiv ID
     * @return ArXiv-issued DOI
     */
    private static String getAutomaticDoi(String arXivId) {
<span class="fc" id="L169">        return DOI_PREFIX + arXivId;</span>
    }

    /**
     * Get ArXiv-issued DOI from the arXiv entry itself.
     * &lt;br/&gt;&lt;br/&gt;
     * ArXiv-issued DOIs are identifiers associated with every ArXiv entry. They are composed of a fixed {@link #DOI_PREFIX} + the entry's ArXiv ID
     *
     * @param arXivBibEntry A Bibtex Entry, formatted as a ArXiv entry. Must contain an EPRINT field
     * @return ArXiv-issued DOI, or Empty, if method could not retrieve it
     */
    private static Optional&lt;String&gt; getAutomaticDoi(BibEntry arXivBibEntry) {
        // As the input should always contain a EPRINT if created from inner 'ArXiv' class, don't bother doing a check that might call
        // ArXiv's API again (method 'findIdentifier')
<span class="nc" id="L183">        Optional&lt;String&gt; entryEprint = arXivBibEntry.getField(StandardField.EPRINT);</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (entryEprint.isEmpty()) {</span>
<span class="nc" id="L185">            LOGGER.error(&quot;Cannot infer ArXiv-issued DOI from BibEntry: no 'EPRINT' field found&quot;);</span>
<span class="nc" id="L186">            return Optional.empty();</span>
        } else {
<span class="nc" id="L188">            return Optional.of(ArXivFetcher.getAutomaticDoi(entryEprint.get()));</span>
        }
    }

    /**
     * Get ArXiv-issued DOI from ArXiv Identifier object
     * &lt;br/&gt;&lt;br/&gt;
     * ArXiv-issued DOIs are identifiers associated with every ArXiv entry. They are composed of a fixed {@link #DOI_PREFIX} + the entry's ArXiv ID
     *
     * @param arXivId An ArXiv ID as internal object
     * @return ArXiv-issued DOI
     */
    private static String getAutomaticDoi(ArXivIdentifier arXivId) {
<span class="fc" id="L201">        return getAutomaticDoi(arXivId.getNormalizedWithoutVersion());</span>
    }

    /**
     * Check if a specific DOI is user-assigned.
     */
    private static boolean isManualDoi(String doi) {
<span class="fc bfc" id="L208" title="All 2 branches covered.">        return !doi.toLowerCase().contains(DOI_PREFIX.toLowerCase());</span>
    }

    /**
     * Get user-issued DOI from ArXiv Bibtex entry, if any
     * &lt;br/&gt;&lt;br/&gt;
     * User-issued DOIs are identifiers associated with some ArXiv entries that can associate an entry with an external service, like
     * &lt;a href=&quot;https://link.springer.com/&quot;&gt;Springer Link&lt;/a&gt;.
     *
     * @param arXivBibEntry An ArXiv Bibtex entry from where the DOI is extracted
     * @return User-issued DOI, if any field exists and if it's not an automatic one (see {@link #getAutomaticDoi(ArXivIdentifier)})
     */
    private static Optional&lt;String&gt; getManualDoi(BibEntry arXivBibEntry) {
<span class="fc" id="L221">        return arXivBibEntry.getField(StandardField.DOI).filter(ArXivFetcher::isManualDoi);</span>
    }

    /**
     * Get the Bibtex Entry from a Future API request (uses blocking) and treat exceptions.
     *
     * @param bibEntryFuture A CompletableFuture that parallelize the API fetching process
     * @return the fetch result
     */
    private static Optional&lt;BibEntry&gt; waitForBibEntryRetrieval(CompletableFuture&lt;Optional&lt;BibEntry&gt;&gt; bibEntryFuture) throws FetcherException {
        try {
<span class="fc" id="L232">            return bibEntryFuture.join();</span>
<span class="fc" id="L233">        } catch (CompletionException e) {</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">            if (!(e.getCause() instanceof FetcherException)) {</span>
<span class="nc" id="L235">                LOGGER.error(&quot;The supplied future should only throw a FetcherException.&quot;, e);</span>
<span class="nc" id="L236">                throw e;</span>
            }
<span class="fc" id="L238">            throw (FetcherException) e.getCause();</span>
        }
    }

    /**
     * Eventually merge the ArXiv Bibtex entry with a Future Bibtex entry (ArXiv/user-assigned DOIs)
     *
     * @param arXivEntry The entry to merge into
     * @param bibEntryFuture A future result of the fetching process
     * @param priorityFields Which fields from &quot;bibEntryFuture&quot; to prioritize, replacing them on &quot;arXivEntry&quot;
     * @param id Identifier used in initiating the &quot;bibEntryFuture&quot; future (for logging). This is usually a DOI, but can be anything.
     */
    private void mergeArXivEntryWithFutureDoiEntry(BibEntry arXivEntry, CompletableFuture&lt;Optional&lt;BibEntry&gt;&gt; bibEntryFuture, Set&lt;Field&gt; priorityFields, String id) {
        Optional&lt;BibEntry&gt; bibEntry;
        try {
<span class="fc" id="L253">            bibEntry = waitForBibEntryRetrieval(bibEntryFuture);</span>
<span class="fc" id="L254">        } catch (FetcherException | CompletionException e) {</span>
<span class="fc" id="L255">            LOGGER.error(&quot;Failed to fetch future BibEntry with id '{}' (skipping merge).&quot;, id, e);</span>
<span class="fc" id="L256">            return;</span>
<span class="fc" id="L257">        }</span>

<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        if (bibEntry.isPresent()) {</span>
<span class="fc" id="L260">            adaptKeywordsFrom(bibEntry.get());</span>
<span class="fc" id="L261">            arXivEntry.mergeWith(bibEntry.get(), priorityFields);</span>
        } else {
<span class="nc" id="L263">            LOGGER.error(&quot;Future BibEntry for id '{}' was completed, but no entry was found (skipping merge).&quot;, id);</span>
        }
<span class="fc" id="L265">    }</span>

    /**
     * Infuse arXivBibEntryPromise with additional fields in an asynchronous way
     *
     * @param arXivBibEntry An existing entry to be updated with new/modified fields
     */
    private void inplaceAsyncInfuseArXivWithDoi(BibEntry arXivBibEntry) {
<span class="fc" id="L273">        CompletableFuture&lt;Optional&lt;BibEntry&gt;&gt; arXivBibEntryCompletedFuture = CompletableFuture.completedFuture(Optional.of(arXivBibEntry));</span>
<span class="fc" id="L274">        Optional&lt;ArXivIdentifier&gt; arXivBibEntryId = arXivBibEntry.getField(StandardField.EPRINT).flatMap(ArXivIdentifier::parse);</span>

        try {
<span class="fc" id="L277">            this.inplaceAsyncInfuseArXivWithDoi(arXivBibEntryCompletedFuture, arXivBibEntryId);</span>
<span class="nc" id="L278">        } catch (FetcherException e) {</span>
<span class="nc" id="L279">            LOGGER.error(&quot;FetcherException should not be found here, as main Bibtex Entry already exists &quot; +</span>
                    &quot;(and failing additional fetches should be skipped)&quot;, e);
<span class="fc" id="L281">        }</span>
<span class="fc" id="L282">    }</span>

    /**
     * Infuse arXivBibEntryFuture with additional fields in an asynchronous way, accelerating the process by providing a valid ArXiv ID
     *
     * @param arXivBibEntryFuture A future entry that (if it exists) will be updated with new/modified fields
     * @param arXivId An ArXiv ID for the main reference (from ArXiv), so that the retrieval of ArXiv-issued DOI metadata can be faster
     * @throws FetcherException when failed to fetch the main ArtXiv Bibtex entry ('arXivBibEntryFuture').
     */
    private void inplaceAsyncInfuseArXivWithDoi(CompletableFuture&lt;Optional&lt;BibEntry&gt;&gt; arXivBibEntryFuture, Optional&lt;ArXivIdentifier&gt; arXivId) throws FetcherException {

        Optional&lt;CompletableFuture&lt;Optional&lt;BibEntry&gt;&gt;&gt; automaticDoiBibEntryFuture;
        Optional&lt;BibEntry&gt; arXivBibEntry;

        Optional&lt;String&gt; automaticDoi;
        Optional&lt;String&gt; manualDoi;

        // We can accelerate the processing time by initiating a parallel request for DOIFetcher with an ArXiv-issued DOI alongside the ArXiv fetching itself,
        // BUT ONLY IF we have a valid arXivId. If not, the ArXiv entry must be retrieved before, which invalidates this optimization (although we can still speed
        // up the process by running both the ArXiv-assigned and user-assigned DOI fetching at the same time, if an entry has this last information)
<span class="fc bfc" id="L302" title="All 2 branches covered.">        if (arXivId.isPresent()) {</span>
<span class="fc" id="L303">            automaticDoi = Optional.of(ArXivFetcher.getAutomaticDoi(arXivId.get()));</span>
<span class="fc" id="L304">            automaticDoiBibEntryFuture = Optional.of(doiFetcher.asyncPerformSearchById(automaticDoi.get()));</span>

<span class="fc" id="L306">            arXivBibEntry = ArXivFetcher.waitForBibEntryRetrieval(arXivBibEntryFuture);</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">            if (arXivBibEntry.isEmpty()) {</span>
<span class="nc" id="L308">                return;</span>
            }
        } else {
            // If ArXiv fetch fails (FetcherException), exception must be passed onwards for the transparency of this class (original ArXiv fetcher does the same)
<span class="fc" id="L312">            arXivBibEntry = ArXivFetcher.waitForBibEntryRetrieval(arXivBibEntryFuture);</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">            if (arXivBibEntry.isEmpty()) {</span>
<span class="fc" id="L314">                return;</span>
            }

<span class="nc" id="L317">            automaticDoi = ArXivFetcher.getAutomaticDoi(arXivBibEntry.get());</span>
<span class="nc" id="L318">            automaticDoiBibEntryFuture = automaticDoi.map(arXiv::asyncPerformSearchById);</span>
        }

<span class="fc" id="L321">        manualDoi = ArXivFetcher.getManualDoi(arXivBibEntry.get());</span>
<span class="fc" id="L322">        Optional&lt;CompletableFuture&lt;Optional&lt;BibEntry&gt;&gt;&gt; manualDoiBibEntryFuture = manualDoi.map(doiFetcher::asyncPerformSearchById);</span>

<span class="fc" id="L324">        automaticDoiBibEntryFuture.ifPresent(future -&gt;</span>
<span class="fc" id="L325">                mergeArXivEntryWithFutureDoiEntry(arXivBibEntry.get(), future, CHOSEN_AUTOMATIC_DOI_FIELDS, automaticDoi.get()));</span>
<span class="fc" id="L326">        manualDoiBibEntryFuture.ifPresent(future -&gt;</span>
<span class="fc" id="L327">                mergeArXivEntryWithFutureDoiEntry(arXivBibEntry.get(), future, CHOSEN_MANUAL_DOI_FIELDS, manualDoi.get()));</span>
<span class="fc" id="L328">    }</span>

    /**
     * Constructs a complex query string using the field prefixes specified at https://arxiv.org/help/api/user-manual
     * and modify resulting BibEntries with additional info from the ArXiv-issued DOI
     *
     * @param luceneQuery the root node of the lucene query
     * @return A list of entries matching the complex query
     */
    @Override
    public Page&lt;BibEntry&gt; performSearchPaged(QueryNode luceneQuery, int pageNumber) throws FetcherException {

<span class="fc" id="L340">        Page&lt;BibEntry&gt; result = arXiv.performSearchPaged(luceneQuery, pageNumber);</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">        if (this.doiFetcher == null) {</span>
<span class="nc" id="L342">            return result;</span>
        }

<span class="fc" id="L345">        ExecutorService executor = Executors.newFixedThreadPool(getPageSize() * 2);</span>

<span class="fc" id="L347">        Collection&lt;CompletableFuture&lt;BibEntry&gt;&gt; futureSearchResult = result.getContent()</span>
<span class="fc" id="L348">                                                                       .stream()</span>
<span class="fc" id="L349">                                                                       .map(bibEntry -&gt;</span>
<span class="fc" id="L350">                                                                               CompletableFuture.supplyAsync(() -&gt; {</span>
<span class="fc" id="L351">                                                                                   this.inplaceAsyncInfuseArXivWithDoi(bibEntry);</span>
<span class="fc" id="L352">                                                                                   return bibEntry;</span>
                                                                               }, executor))
<span class="fc" id="L354">                                                                       .toList();</span>

<span class="fc" id="L356">        Collection&lt;BibEntry&gt; modifiedSearchResult = futureSearchResult.stream()</span>
<span class="fc" id="L357">                                      .map(CompletableFuture::join)</span>
<span class="fc" id="L358">                                      .collect(Collectors.toList());</span>

<span class="fc" id="L360">        return new Page&lt;&gt;(result.getQuery(), result.getPageNumber(), modifiedSearchResult);</span>
    }

    @Override
    public Optional&lt;BibEntry&gt; performSearchById(String identifier) throws FetcherException {
<span class="fc" id="L365">        CompletableFuture&lt;Optional&lt;BibEntry&gt;&gt; arXivBibEntryPromise = arXiv.asyncPerformSearchById(identifier);</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">        if (this.doiFetcher != null) {</span>
<span class="fc" id="L367">            inplaceAsyncInfuseArXivWithDoi(arXivBibEntryPromise, ArXivIdentifier.parse(identifier));</span>
        }
<span class="fc" id="L369">        return arXivBibEntryPromise.join();</span>
    }

    @Override
    public Optional&lt;ArXivIdentifier&gt; findIdentifier(BibEntry entry) throws FetcherException {
<span class="fc" id="L374">        return arXiv.findIdentifier(entry);</span>
    }

    @Override
    public String getIdentifierName() {
<span class="nc" id="L379">        return arXiv.getIdentifierName();</span>
    }

    /**
     * Fetcher for the arXiv.
     *
     * @see &lt;a href=&quot;https://arxiv.org/help/api/index&quot;&gt;ArXiv API&lt;/a&gt; for an overview of the API
     * @see &lt;a href=&quot;https://arxiv.org/help/api/user-manual#_calling_the_api&quot;&gt;ArXiv API User's Manual&lt;/a&gt; for a detailed
     * description on how to use the API
     * &lt;p&gt;
     * Similar implementions:
     * &lt;a href=&quot;https://github.com/nathangrigg/arxiv2bib&quot;&gt;arxiv2bib&lt;/a&gt; which is &lt;a href=&quot;https://arxiv2bibtex.org/&quot;&gt;live&lt;/a&gt;
     * &lt;a href=&quot;https://gitlab.c3sl.ufpr.br/portalmec/dspace-portalmec/blob/aa209d15082a9870f9daac42c78a35490ce77b52/dspace-api/src/main/java/org/dspace/submit/lookup/ArXivService.java&quot;&gt;dspace-portalmec&lt;/a&gt;
     */
    protected class ArXiv implements FulltextFetcher, PagedSearchBasedFetcher, IdBasedFetcher, IdFetcher&lt;ArXivIdentifier&gt; {

<span class="fc" id="L395">        private static final Logger LOGGER = LoggerFactory.getLogger(ArXivFetcher.ArXiv.class);</span>

        private static final String API_URL = &quot;https://export.arxiv.org/api/query&quot;;

        private final ImportFormatPreferences importFormatPreferences;

<span class="fc" id="L401">        public ArXiv(ImportFormatPreferences importFormatPreferences) {</span>
<span class="fc" id="L402">            this.importFormatPreferences = importFormatPreferences;</span>
<span class="fc" id="L403">        }</span>

        @Override
        public Optional&lt;URL&gt; findFullText(BibEntry entry) throws IOException {
<span class="fc" id="L407">            Objects.requireNonNull(entry);</span>

            try {
<span class="fc" id="L410">                Optional&lt;URL&gt; pdfUrl = searchForEntries(entry).stream()</span>
<span class="fc" id="L411">                                                              .map(ArXivEntry::getPdfUrl)</span>
<span class="fc" id="L412">                                                              .filter(Optional::isPresent)</span>
<span class="fc" id="L413">                                                              .map(Optional::get)</span>
<span class="fc" id="L414">                                                              .findFirst();</span>
<span class="fc" id="L415">                pdfUrl.ifPresent(url -&gt; LOGGER.info(&quot;Fulltext PDF found @ arXiv.&quot;));</span>
<span class="fc" id="L416">                return pdfUrl;</span>
<span class="nc" id="L417">            } catch (FetcherException e) {</span>
<span class="nc" id="L418">                LOGGER.warn(&quot;arXiv API request failed&quot;, e);</span>
            }

<span class="nc" id="L421">            return Optional.empty();</span>
        }

        @Override
        public TrustLevel getTrustLevel() {
<span class="fc" id="L426">            return TrustLevel.PREPRINT;</span>
        }

        private Optional&lt;ArXivEntry&gt; searchForEntry(String searchQuery) throws FetcherException {
<span class="fc" id="L430">            List&lt;ArXivEntry&gt; entries = queryApi(searchQuery, Collections.emptyList(), 0, 1);</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">            if (entries.size() == 1) {</span>
<span class="fc" id="L432">                return Optional.of(entries.getFirst());</span>
            } else {
<span class="fc" id="L434">                return Optional.empty();</span>
            }
        }

        private Optional&lt;ArXivEntry&gt; searchForEntryById(String id) throws FetcherException {
<span class="fc" id="L439">            Optional&lt;ArXivIdentifier&gt; identifier = ArXivIdentifier.parse(id);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">            if (identifier.isEmpty()) {</span>
<span class="fc" id="L441">                return Optional.empty();</span>
            }

<span class="fc" id="L444">            List&lt;ArXivEntry&gt; entries = queryApi(&quot;&quot;, Collections.singletonList(identifier.get()), 0, 1);</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">            if (!entries.isEmpty()) {</span>
<span class="fc" id="L446">                return Optional.of(entries.getFirst());</span>
            } else {
<span class="fc" id="L448">                return Optional.empty();</span>
            }
        }

        private List&lt;ArXivEntry&gt; searchForEntries(BibEntry originalEntry) throws FetcherException {
            // We need to clone the entry, because we modify it by a cleanup job.
<span class="fc" id="L454">            final BibEntry entry = (BibEntry) originalEntry.clone();</span>

            // 1. Check for Eprint
<span class="fc" id="L457">            new EprintCleanup().cleanup(entry);</span>
<span class="fc" id="L458">            Optional&lt;String&gt; identifier = entry.getField(StandardField.EPRINT);</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">            if (StringUtil.isNotBlank(identifier)) {</span>
                try {
                    // Get pdf of entry with the specified id
<span class="fc" id="L462">                    return OptionalUtil.toList(searchForEntryById(identifier.get()));</span>
<span class="nc" id="L463">                } catch (FetcherException e) {</span>
<span class="nc" id="L464">                    LOGGER.warn(&quot;arXiv eprint API request failed&quot;, e);</span>
                }
            }

            // 2. DOI and other fields
            String query;
<span class="fc" id="L470">            Optional&lt;String&gt; doiString = entry.getField(StandardField.DOI)</span>
<span class="fc" id="L471">                                              .flatMap(DOI::parse)</span>
<span class="fc" id="L472">                                              .map(DOI::getNormalized);</span>

            // ArXiv-issued DOIs seem to be unsearchable from ArXiv API's &quot;query string&quot;, so ignore it
<span class="fc bfc" id="L475" title="All 4 branches covered.">            if (doiString.isPresent() &amp;&amp; ArXivFetcher.isManualDoi(doiString.get())) {</span>
<span class="fc" id="L476">                query = &quot;doi:&quot; + doiString.get();</span>
            } else {
<span class="fc" id="L478">                Optional&lt;String&gt; authorQuery = entry.getField(StandardField.AUTHOR).map(author -&gt; &quot;au:&quot; + author);</span>
<span class="fc" id="L479">                Optional&lt;String&gt; titleQuery = entry.getField(StandardField.TITLE).map(title -&gt; &quot;ti:&quot; + StringUtil.ignoreCurlyBracket(title));</span>
<span class="fc" id="L480">                query = String.join(&quot;+AND+&quot;, OptionalUtil.toList(authorQuery, titleQuery));</span>
            }

<span class="fc" id="L483">            Optional&lt;ArXivEntry&gt; arxivEntry = searchForEntry(query);</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">            if (arxivEntry.isPresent()) {</span>
                // Check if entry is a match
<span class="fc" id="L486">                StringSimilarity match = new StringSimilarity();</span>
<span class="fc" id="L487">                String arxivTitle = arxivEntry.get().title.orElse(&quot;&quot;);</span>
<span class="fc" id="L488">                String entryTitle = StringUtil.ignoreCurlyBracket(entry.getField(StandardField.TITLE).orElse(&quot;&quot;));</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">                if (match.isSimilar(arxivTitle, entryTitle)) {</span>
<span class="fc" id="L490">                    return OptionalUtil.toList(arxivEntry);</span>
                }
            }

<span class="fc" id="L494">            return Collections.emptyList();</span>
        }

        private List&lt;ArXivEntry&gt; searchForEntries(String searchQuery, int pageNumber) throws FetcherException {
<span class="fc" id="L498">            return queryApi(searchQuery, Collections.emptyList(), getPageSize() * pageNumber, getPageSize());</span>
        }

        private List&lt;ArXivEntry&gt; queryApi(String searchQuery, List&lt;ArXivIdentifier&gt; ids, int start, int maxResults)
                throws FetcherException {
<span class="fc" id="L503">            Document result = callApi(searchQuery, ids, start, maxResults);</span>
<span class="fc" id="L504">            List&lt;Node&gt; entries = XMLUtil.asList(result.getElementsByTagName(&quot;entry&quot;));</span>

<span class="fc" id="L506">            return entries.stream().map(ArXivEntry::new).collect(Collectors.toList());</span>
        }

        /**
         * Queries the API.
         * &lt;p&gt;
         * If only {@code searchQuery} is given, then the API will return results for each article that matches the query.
         * If only {@code ids} is given, then the API will return results for each article in the list.
         * If both {@code searchQuery} and {@code ids} are given, then the API will return each article in
         * {@code ids} that matches {@code searchQuery}. This allows the API to act as a results filter.
         *
         * @param searchQuery the search query used to find articles;
         *                    &lt;a href=&quot;http://arxiv.org/help/api/user-manual#query_details&quot;&gt;details&lt;/a&gt;
         * @param ids         a list of arXiv identifiers
         * @param start       the index of the first returned result (zero-based)
         * @param maxResults  the number of maximal results (has to be smaller than 2000)
         * @return the response from the API as a XML document (Atom 1.0)
         * @throws FetcherException if there was a problem while building the URL or the API was not accessible
         */
        private Document callApi(String searchQuery, List&lt;ArXivIdentifier&gt; ids, int start, int maxResults) throws FetcherException {
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">            if (maxResults &gt; 2000) {</span>
<span class="nc" id="L527">                throw new IllegalArgumentException(&quot;The arXiv API limits the number of maximal results to be 2000&quot;);</span>
            }

            try {
<span class="fc" id="L531">                URIBuilder uriBuilder = new URIBuilder(API_URL);</span>
                // The arXiv API has problems with accents, so we remove them (i.e. Fr√©chet -&gt; Frechet)
<span class="fc bfc" id="L533" title="All 2 branches covered.">                if (StringUtil.isNotBlank(searchQuery)) {</span>
<span class="fc" id="L534">                    uriBuilder.addParameter(&quot;search_query&quot;, StringUtil.stripAccents(searchQuery));</span>
                }
<span class="fc bfc" id="L536" title="All 2 branches covered.">                if (!ids.isEmpty()) {</span>
<span class="fc" id="L537">                    uriBuilder.addParameter(&quot;id_list&quot;,</span>
<span class="fc" id="L538">                            ids.stream().map(ArXivIdentifier::getNormalized).collect(Collectors.joining(&quot;,&quot;)));</span>
                }
<span class="fc" id="L540">                uriBuilder.addParameter(&quot;start&quot;, String.valueOf(start));</span>
<span class="fc" id="L541">                uriBuilder.addParameter(&quot;max_results&quot;, String.valueOf(maxResults));</span>
<span class="fc" id="L542">                URL url = uriBuilder.build().toURL();</span>

<span class="fc" id="L544">                DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span>
<span class="fc" id="L545">                DocumentBuilder builder = factory.newDocumentBuilder();</span>

<span class="fc" id="L547">                HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span>
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">                if (connection.getResponseCode() == 400) {</span>
                    // Bad request error from server, try to get more information
<span class="nc" id="L550">                    throw getException(builder.parse(connection.getErrorStream()));</span>
                } else {
<span class="fc" id="L552">                    return builder.parse(connection.getInputStream());</span>
                }
<span class="nc" id="L554">            } catch (SAXException | ParserConfigurationException | IOException | URISyntaxException exception) {</span>
<span class="nc" id="L555">                throw new FetcherException(&quot;arXiv API request failed&quot;, exception);</span>
            }
        }

        private FetcherException getException(Document error) {
<span class="nc" id="L560">            List&lt;Node&gt; entries = XMLUtil.asList(error.getElementsByTagName(&quot;entry&quot;));</span>

            // Check if the API returned an error
            // In case of an error, only one entry will be returned with the error information. For example:
            // https://export.arxiv.org/api/query?id_list=0307015
            // &lt;entry&gt;
            //      &lt;id&gt;https://arxiv.org/api/errors#incorrect_id_format_for_0307015&lt;/id&gt;
            //      &lt;title&gt;Error&lt;/title&gt;
            //      &lt;summary&gt;incorrect id format for 0307015&lt;/summary&gt;
            // &lt;/entry&gt;
<span class="nc bnc" id="L570" title="All 2 branches missed.">            if (entries.size() == 1) {</span>
<span class="nc" id="L571">                Node node = entries.getFirst();</span>
<span class="nc" id="L572">                Optional&lt;String&gt; id = XMLUtil.getNodeContent(node, &quot;id&quot;);</span>
<span class="nc" id="L573">                Boolean isError = id.map(idContent -&gt; idContent.startsWith(&quot;http://arxiv.org/api/errors&quot;)).orElse(false);</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">                if (isError) {</span>
<span class="nc" id="L575">                    String errorMessage = XMLUtil.getNodeContent(node, &quot;summary&quot;).orElse(&quot;Unknown error&quot;);</span>
<span class="nc" id="L576">                    return new FetcherException(errorMessage);</span>
                }
            }
<span class="nc" id="L579">            return new FetcherException(&quot;arXiv API request failed&quot;);</span>
        }

        @Override
        public String getName() {
<span class="fc" id="L584">            return &quot;ArXiv&quot;;</span>
        }

        @Override
        public Optional&lt;HelpFile&gt; getHelpPage() {
<span class="nc" id="L589">            return Optional.of(HelpFile.FETCHER_OAI2_ARXIV);</span>
        }

        /**
         * Constructs a complex query string using the field prefixes specified at https://arxiv.org/help/api/user-manual
         *
         * @param luceneQuery the root node of the lucene query
         * @return A list of entries matching the complex query
         */
        @Override
        public Page&lt;BibEntry&gt; performSearchPaged(QueryNode luceneQuery, int pageNumber) throws FetcherException {
<span class="fc" id="L600">            ArXivQueryTransformer transformer = new ArXivQueryTransformer();</span>
<span class="fc" id="L601">            String transformedQuery = transformer.transformLuceneQuery(luceneQuery).orElse(&quot;&quot;);</span>
<span class="fc" id="L602">            List&lt;BibEntry&gt; searchResult = searchForEntries(transformedQuery, pageNumber)</span>
<span class="fc" id="L603">                    .stream()</span>
<span class="fc" id="L604">                    .map(arXivEntry -&gt; arXivEntry.toBibEntry(importFormatPreferences.bibEntryPreferences().getKeywordSeparator()))</span>
<span class="fc" id="L605">                    .collect(Collectors.toList());</span>
<span class="fc" id="L606">            return new Page&lt;&gt;(transformedQuery, pageNumber, filterYears(searchResult, transformer));</span>
        }

        private List&lt;BibEntry&gt; filterYears(List&lt;BibEntry&gt; searchResult, ArXivQueryTransformer transformer) {
<span class="fc" id="L610">            return searchResult.stream()</span>
<span class="fc" id="L611">                               .filter(entry -&gt; entry.getField(StandardField.DATE).isPresent())</span>
                               // Filter the date field for year only
<span class="pc bpc" id="L613" title="3 of 4 branches missed.">                               .filter(entry -&gt; transformer.getEndYear().isEmpty() || (Integer.parseInt(entry.getField(StandardField.DATE).get().substring(0, 4)) &lt;= transformer.getEndYear().get()))</span>
<span class="pc bpc" id="L614" title="3 of 4 branches missed.">                               .filter(entry -&gt; transformer.getStartYear().isEmpty() || (Integer.parseInt(entry.getField(StandardField.DATE).get().substring(0, 4)) &gt;= transformer.getStartYear().get()))</span>
<span class="fc" id="L615">                               .collect(Collectors.toList());</span>
        }

        protected CompletableFuture&lt;Optional&lt;BibEntry&gt;&gt; asyncPerformSearchById(String identifier) throws CompletionException {
<span class="fc" id="L619">            return CompletableFuture.supplyAsync(() -&gt; {</span>
                try {
<span class="fc" id="L621">                    return performSearchById(identifier);</span>
<span class="nc" id="L622">                } catch (FetcherException e) {</span>
<span class="nc" id="L623">                    throw new CompletionException(e);</span>
                }
            });
        }

        @Override
        public Optional&lt;BibEntry&gt; performSearchById(String identifier) throws FetcherException {
<span class="fc" id="L630">            return searchForEntryById(identifier)</span>
<span class="fc" id="L631">                    .map(arXivEntry -&gt; arXivEntry.toBibEntry(importFormatPreferences.bibEntryPreferences().getKeywordSeparator()));</span>
        }

        @Override
        public Optional&lt;ArXivIdentifier&gt; findIdentifier(BibEntry entry) throws FetcherException {
<span class="fc" id="L636">            return searchForEntries(entry).stream()</span>
<span class="fc" id="L637">                                          .map(ArXivEntry::getId)</span>
<span class="fc" id="L638">                                          .filter(Optional::isPresent)</span>
<span class="fc" id="L639">                                          .map(Optional::get)</span>
<span class="fc" id="L640">                                          .findFirst();</span>
        }

        @Override
        public String getIdentifierName() {
<span class="nc" id="L645">            return &quot;ArXiv&quot;;</span>
        }

        private static class ArXivEntry {

            private final Optional&lt;String&gt; title;
            private final Optional&lt;String&gt; urlAbstractPage;
            private final Optional&lt;String&gt; publishedDate;
            private final Optional&lt;String&gt; abstractText;
            private final List&lt;String&gt; authorNames;
            private final List&lt;String&gt; categories;
            private final Optional&lt;URL&gt; pdfUrl;
            private final Optional&lt;String&gt; doi;
            private final Optional&lt;String&gt; journalReferenceText;
            private final Optional&lt;String&gt; primaryCategory;

<span class="fc" id="L661">            public ArXivEntry(Node item) {</span>
                // see https://arxiv.org/help/api/user-manual#_details_of_atom_results_returned

                // Title of the article
                // The result from the arXiv contains hard line breaks, try to remove them
<span class="fc" id="L666">                title = XMLUtil.getNodeContent(item, &quot;title&quot;).map(ArXivEntry::correctLineBreaks);</span>

                // The url leading to the abstract page
<span class="fc" id="L669">                urlAbstractPage = XMLUtil.getNodeContent(item, &quot;id&quot;);</span>

                // Date on which the first version was published
<span class="fc" id="L672">                publishedDate = XMLUtil.getNodeContent(item, &quot;published&quot;);</span>

                // Abstract of the article
<span class="fc" id="L675">                abstractText = XMLUtil.getNodeContent(item, &quot;summary&quot;).map(ArXivEntry::correctLineBreaks)</span>
<span class="fc" id="L676">                                      .map(String::trim);</span>

                // Authors of the article
<span class="fc" id="L679">                authorNames = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">                for (Node authorNode : XMLUtil.getNodesByName(item, &quot;author&quot;)) {</span>
<span class="fc" id="L681">                    Optional&lt;String&gt; authorName = XMLUtil.getNodeContent(authorNode, &quot;name&quot;).map(String::trim);</span>
<span class="fc" id="L682">                    authorName.ifPresent(authorNames::add);</span>
<span class="fc" id="L683">                }</span>

                // Categories (arXiv, ACM, or MSC classification)
<span class="fc" id="L686">                categories = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">                for (Node categoryNode : XMLUtil.getNodesByName(item, &quot;category&quot;)) {</span>
<span class="fc" id="L688">                    Optional&lt;String&gt; category = XMLUtil.getAttributeContent(categoryNode, &quot;term&quot;);</span>
<span class="fc" id="L689">                    category.ifPresent(categories::add);</span>
<span class="fc" id="L690">                }</span>

                // Links
<span class="fc" id="L693">                Optional&lt;URL&gt; pdfUrlParsed = Optional.empty();</span>
<span class="fc bfc" id="L694" title="All 2 branches covered.">                for (Node linkNode : XMLUtil.getNodesByName(item, &quot;link&quot;)) {</span>
<span class="fc" id="L695">                    Optional&lt;String&gt; linkTitle = XMLUtil.getAttributeContent(linkNode, &quot;title&quot;);</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">                    if (linkTitle.equals(Optional.of(&quot;pdf&quot;))) {</span>
<span class="fc" id="L697">                        pdfUrlParsed = XMLUtil.getAttributeContent(linkNode, &quot;href&quot;).map(url -&gt; {</span>
                            try {
<span class="fc" id="L699">                                return new URL(url);</span>
<span class="nc" id="L700">                            } catch (MalformedURLException e) {</span>
<span class="nc" id="L701">                                return null;</span>
                            }
                        });
                    }
<span class="fc" id="L705">                }</span>
<span class="fc" id="L706">                pdfUrl = pdfUrlParsed;</span>

                // Associated DOI
<span class="fc" id="L709">                doi = XMLUtil.getNodeContent(item, &quot;arxiv:doi&quot;);</span>

                // Journal reference (as provided by the author)
<span class="fc" id="L712">                journalReferenceText = XMLUtil.getNodeContent(item, &quot;arxiv:journal_ref&quot;);</span>

                // Primary category
                // Ex: &lt;arxiv:primary_category xmlns:arxiv=&quot;https://arxiv.org/schemas/atom&quot; term=&quot;math-ph&quot; scheme=&quot;http://arxiv.org/schemas/atom&quot;/&gt;
<span class="fc" id="L716">                primaryCategory = XMLUtil.getNode(item, &quot;arxiv:primary_category&quot;)</span>
<span class="fc" id="L717">                                         .flatMap(node -&gt; XMLUtil.getAttributeContent(node, &quot;term&quot;));</span>
<span class="fc" id="L718">            }</span>

            public static String correctLineBreaks(String s) {
<span class="fc" id="L721">                String result = s.replaceAll(&quot;\\n(?!\\s*\\n)&quot;, &quot; &quot;);</span>
<span class="fc" id="L722">                result = result.replaceAll(&quot;\\s*\\n\\s*&quot;, &quot;\n&quot;);</span>
<span class="fc" id="L723">                return result.replaceAll(&quot; {2,}&quot;, &quot; &quot;).replaceAll(&quot;(^\\s*|\\s+$)&quot;, &quot;&quot;);</span>
            }

            /**
             * Returns the url of the linked pdf
             */
            public Optional&lt;URL&gt; getPdfUrl() {
<span class="fc" id="L730">                return pdfUrl;</span>
            }

            /**
             * Returns the arXiv identifier
             */
            public Optional&lt;String&gt; getIdString() {
<span class="fc" id="L737">                return urlAbstractPage.flatMap(ArXivIdentifier::parse).map(ArXivIdentifier::getNormalizedWithoutVersion);</span>
            }

            public Optional&lt;ArXivIdentifier&gt; getId() {
<span class="fc" id="L741">                return getIdString().flatMap(ArXivIdentifier::parse);</span>
            }

            /**
             * Returns the date when the first version was put on the arXiv
             */
            public Optional&lt;String&gt; getDate() {
                // Publication string also contains time, e.g. 2014-05-09T14:49:43Z
<span class="fc" id="L749">                return publishedDate.map(date -&gt; {</span>
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">                    if (date.length() &lt; 10) {</span>
<span class="nc" id="L751">                        return null;</span>
                    } else {
<span class="fc" id="L753">                        return date.substring(0, 10);</span>
                    }
                });
            }

            public BibEntry toBibEntry(Character keywordDelimiter) {
<span class="fc" id="L759">                BibEntry bibEntry = new BibEntry(StandardEntryType.Article);</span>
<span class="fc" id="L760">                bibEntry.setField(StandardField.EPRINTTYPE, &quot;arXiv&quot;);</span>
<span class="fc" id="L761">                bibEntry.setField(StandardField.AUTHOR, String.join(&quot; and &quot;, authorNames));</span>
<span class="fc" id="L762">                bibEntry.addKeywords(categories, keywordDelimiter);</span>
<span class="fc" id="L763">                getIdString().ifPresent(id -&gt; bibEntry.setField(StandardField.EPRINT, id));</span>
<span class="fc" id="L764">                title.ifPresent(titleContent -&gt; bibEntry.setField(StandardField.TITLE, titleContent));</span>
<span class="fc" id="L765">                doi.ifPresent(doiContent -&gt; bibEntry.setField(StandardField.DOI, doiContent));</span>
<span class="fc" id="L766">                abstractText.ifPresent(abstractContent -&gt; bibEntry.setField(StandardField.ABSTRACT, abstractContent));</span>
<span class="fc" id="L767">                getDate().ifPresent(date -&gt; bibEntry.setField(StandardField.DATE, date));</span>
<span class="fc" id="L768">                primaryCategory.ifPresent(category -&gt; bibEntry.setField(StandardField.EPRINTCLASS, category));</span>
<span class="fc" id="L769">                journalReferenceText.ifPresent(journal -&gt; bibEntry.setField(StandardField.JOURNAL, journal));</span>
<span class="fc" id="L770">                getPdfUrl().ifPresent(url -&gt; bibEntry.setFiles(Collections.singletonList(new LinkedFile(url, &quot;PDF&quot;))));</span>
<span class="fc" id="L771">                return bibEntry;</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>