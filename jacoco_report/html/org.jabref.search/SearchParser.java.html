<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SearchParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JabRef</a> &gt; <a href="index.source.html" class="el_package">org.jabref.search</a> &gt; <span class="el_source">SearchParser.java</span></div><h1>SearchParser.java</h1><pre class="source lang-java linenums">// Generated from C:/Users/RG/Documents/KTH/SE/lab3/jabref_26/src/main/antlr4/org/jabref/search/Search.g4 by ANTLR 4.13.1
package org.jabref.search;
import org.antlr.v4.runtime.atn.*;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.misc.*;
import org.antlr.v4.runtime.tree.*;
import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;

@SuppressWarnings({&quot;all&quot;, &quot;warnings&quot;, &quot;unchecked&quot;, &quot;unused&quot;, &quot;cast&quot;, &quot;CheckReturnValue&quot;})
public class SearchParser extends Parser {
<span class="fc" id="L14">	static { RuntimeMetaData.checkVersion(&quot;4.13.1&quot;, RuntimeMetaData.VERSION); }</span>

	protected static final DFA[] _decisionToDFA;
<span class="fc" id="L17">	protected static final PredictionContextCache _sharedContextCache =</span>
		new PredictionContextCache();
	public static final int
		WS=1, LPAREN=2, RPAREN=3, EQUAL=4, EEQUAL=5, NEQUAL=6, AND=7, OR=8, CONTAINS=9, 
		MATCHES=10, NOT=11, STRING=12, QUOTE=13, FIELDTYPE=14;
	public static final int
		RULE_start = 0, RULE_expression = 1, RULE_comparison = 2, RULE_name = 3;
	private static String[] makeRuleNames() {
<span class="fc" id="L25">		return new String[] {</span>
			&quot;start&quot;, &quot;expression&quot;, &quot;comparison&quot;, &quot;name&quot;
		};
	}
<span class="fc" id="L29">	public static final String[] ruleNames = makeRuleNames();</span>

	private static String[] makeLiteralNames() {
<span class="fc" id="L32">		return new String[] {</span>
			null, null, &quot;'('&quot;, &quot;')'&quot;, &quot;'='&quot;, &quot;'=='&quot;, &quot;'!='&quot;, null, null, null, null, 
			null, null, &quot;'\&quot;'&quot;
		};
	}
<span class="fc" id="L37">	private static final String[] _LITERAL_NAMES = makeLiteralNames();</span>
	private static String[] makeSymbolicNames() {
<span class="fc" id="L39">		return new String[] {</span>
			null, &quot;WS&quot;, &quot;LPAREN&quot;, &quot;RPAREN&quot;, &quot;EQUAL&quot;, &quot;EEQUAL&quot;, &quot;NEQUAL&quot;, &quot;AND&quot;, &quot;OR&quot;, 
			&quot;CONTAINS&quot;, &quot;MATCHES&quot;, &quot;NOT&quot;, &quot;STRING&quot;, &quot;QUOTE&quot;, &quot;FIELDTYPE&quot;
		};
	}
<span class="fc" id="L44">	private static final String[] _SYMBOLIC_NAMES = makeSymbolicNames();</span>
<span class="fc" id="L45">	public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);</span>

	/**
	 * @deprecated Use {@link #VOCABULARY} instead.
	 */
	@Deprecated
	public static final String[] tokenNames;
	static {
<span class="fc" id="L53">		tokenNames = new String[_SYMBOLIC_NAMES.length];</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">		for (int i = 0; i &lt; tokenNames.length; i++) {</span>
<span class="fc" id="L55">			tokenNames[i] = VOCABULARY.getLiteralName(i);</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">			if (tokenNames[i] == null) {</span>
<span class="fc" id="L57">				tokenNames[i] = VOCABULARY.getSymbolicName(i);</span>
			}

<span class="fc bfc" id="L60" title="All 2 branches covered.">			if (tokenNames[i] == null) {</span>
<span class="fc" id="L61">				tokenNames[i] = &quot;&lt;INVALID&gt;&quot;;</span>
			}
		}
	}

	@Override
	@Deprecated
	public String[] getTokenNames() {
<span class="nc" id="L69">		return tokenNames;</span>
	}

	@Override

	public Vocabulary getVocabulary() {
<span class="nc" id="L75">		return VOCABULARY;</span>
	}

	@Override
<span class="nc" id="L79">	public String getGrammarFileName() { return &quot;Search.g4&quot;; }</span>

	@Override
<span class="nc" id="L82">	public String[] getRuleNames() { return ruleNames; }</span>

	@Override
<span class="nc" id="L85">	public String getSerializedATN() { return _serializedATN; }</span>

	@Override
<span class="nc" id="L88">	public ATN getATN() { return _ATN; }</span>

	public SearchParser(TokenStream input) {
<span class="fc" id="L91">		super(input);</span>
<span class="fc" id="L92">		_interp = new ParserATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);</span>
<span class="fc" id="L93">	}</span>

	@SuppressWarnings(&quot;CheckReturnValue&quot;)
	public static class StartContext extends ParserRuleContext {
		public ExpressionContext expression() {
<span class="fc" id="L98">			return getRuleContext(ExpressionContext.class,0);</span>
		}
<span class="nc" id="L100">		public TerminalNode EOF() { return getToken(SearchParser.EOF, 0); }</span>
		public StartContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L102">			super(parent, invokingState);</span>
<span class="fc" id="L103">		}</span>
<span class="nc" id="L104">		@Override public int getRuleIndex() { return RULE_start; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">			if ( visitor instanceof SearchVisitor ) return ((SearchVisitor&lt;? extends T&gt;)visitor).visitStart(this);</span>
<span class="nc" id="L108">			else return visitor.visitChildren(this);</span>
		}
	}

	public final StartContext start() throws RecognitionException {
<span class="fc" id="L113">		StartContext _localctx = new StartContext(_ctx, getState());</span>
<span class="fc" id="L114">		enterRule(_localctx, 0, RULE_start);</span>
		try {
<span class="fc" id="L116">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L118">			setState(8);</span>
<span class="fc" id="L119">			expression(0);</span>
<span class="fc" id="L120">			setState(9);</span>
<span class="fc" id="L121">			match(EOF);</span>
			}
		}
<span class="nc" id="L124">		catch (RecognitionException re) {</span>
<span class="nc" id="L125">			_localctx.exception = re;</span>
<span class="nc" id="L126">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L127">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L130">			exitRule();</span>
		}
<span class="fc" id="L132">		return _localctx;</span>
	}

	@SuppressWarnings(&quot;CheckReturnValue&quot;)
	public static class ExpressionContext extends ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L138">			super(parent, invokingState);</span>
<span class="fc" id="L139">		}</span>
<span class="nc" id="L140">		@Override public int getRuleIndex() { return RULE_expression; }</span>
	 
<span class="fc" id="L142">		public ExpressionContext() { }</span>
		public void copyFrom(ExpressionContext ctx) {
<span class="fc" id="L144">			super.copyFrom(ctx);</span>
<span class="fc" id="L145">		}</span>
	}
	@SuppressWarnings(&quot;CheckReturnValue&quot;)
	public static class BinaryExpressionContext extends ExpressionContext {
		public ExpressionContext left;
		public Token operator;
		public ExpressionContext right;
		public List&lt;ExpressionContext&gt; expression() {
<span class="nc" id="L153">			return getRuleContexts(ExpressionContext.class);</span>
		}
		public ExpressionContext expression(int i) {
<span class="nc" id="L156">			return getRuleContext(ExpressionContext.class,i);</span>
		}
<span class="nc" id="L158">		public TerminalNode AND() { return getToken(SearchParser.AND, 0); }</span>
<span class="nc" id="L159">		public TerminalNode OR() { return getToken(SearchParser.OR, 0); }</span>
<span class="fc" id="L160">		public BinaryExpressionContext(ExpressionContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">			if ( visitor instanceof SearchVisitor ) return ((SearchVisitor&lt;? extends T&gt;)visitor).visitBinaryExpression(this);</span>
<span class="nc" id="L164">			else return visitor.visitChildren(this);</span>
		}
	}
	@SuppressWarnings(&quot;CheckReturnValue&quot;)
	public static class AtomExpressionContext extends ExpressionContext {
		public ComparisonContext comparison() {
<span class="nc" id="L170">			return getRuleContext(ComparisonContext.class,0);</span>
		}
<span class="fc" id="L172">		public AtomExpressionContext(ExpressionContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">			if ( visitor instanceof SearchVisitor ) return ((SearchVisitor&lt;? extends T&gt;)visitor).visitAtomExpression(this);</span>
<span class="nc" id="L176">			else return visitor.visitChildren(this);</span>
		}
	}
	@SuppressWarnings(&quot;CheckReturnValue&quot;)
	public static class ParenExpressionContext extends ExpressionContext {
<span class="nc" id="L181">		public TerminalNode LPAREN() { return getToken(SearchParser.LPAREN, 0); }</span>
		public ExpressionContext expression() {
<span class="fc" id="L183">			return getRuleContext(ExpressionContext.class,0);</span>
		}
<span class="nc" id="L185">		public TerminalNode RPAREN() { return getToken(SearchParser.RPAREN, 0); }</span>
<span class="fc" id="L186">		public ParenExpressionContext(ExpressionContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">			if ( visitor instanceof SearchVisitor ) return ((SearchVisitor&lt;? extends T&gt;)visitor).visitParenExpression(this);</span>
<span class="nc" id="L190">			else return visitor.visitChildren(this);</span>
		}
	}
	@SuppressWarnings(&quot;CheckReturnValue&quot;)
	public static class UnaryExpressionContext extends ExpressionContext {
<span class="nc" id="L195">		public TerminalNode NOT() { return getToken(SearchParser.NOT, 0); }</span>
		public ExpressionContext expression() {
<span class="fc" id="L197">			return getRuleContext(ExpressionContext.class,0);</span>
		}
<span class="fc" id="L199">		public UnaryExpressionContext(ExpressionContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">			if ( visitor instanceof SearchVisitor ) return ((SearchVisitor&lt;? extends T&gt;)visitor).visitUnaryExpression(this);</span>
<span class="nc" id="L203">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ExpressionContext expression() throws RecognitionException {
<span class="nc" id="L208">		return expression(0);</span>
	}

	private ExpressionContext expression(int _p) throws RecognitionException {
<span class="fc" id="L212">		ParserRuleContext _parentctx = _ctx;</span>
<span class="fc" id="L213">		int _parentState = getState();</span>
<span class="fc" id="L214">		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);</span>
<span class="fc" id="L215">		ExpressionContext _prevctx = _localctx;</span>
<span class="fc" id="L216">		int _startState = 2;</span>
<span class="fc" id="L217">		enterRecursionRule(_localctx, 2, RULE_expression, _p);</span>
		try {
			int _alt;
<span class="fc" id="L220">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L222">			setState(19);</span>
<span class="fc" id="L223">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L224" title="1 of 4 branches missed.">			switch (_input.LA(1)) {</span>
			case LPAREN:
				{
<span class="fc" id="L227">				_localctx = new ParenExpressionContext(_localctx);</span>
<span class="fc" id="L228">				_ctx = _localctx;</span>
<span class="fc" id="L229">				_prevctx = _localctx;</span>

<span class="fc" id="L231">				setState(12);</span>
<span class="fc" id="L232">				match(LPAREN);</span>
<span class="fc" id="L233">				setState(13);</span>
<span class="fc" id="L234">				expression(0);</span>
<span class="fc" id="L235">				setState(14);</span>
<span class="fc" id="L236">				match(RPAREN);</span>
				}
<span class="fc" id="L238">				break;</span>
			case NOT:
				{
<span class="fc" id="L241">				_localctx = new UnaryExpressionContext(_localctx);</span>
<span class="fc" id="L242">				_ctx = _localctx;</span>
<span class="fc" id="L243">				_prevctx = _localctx;</span>
<span class="fc" id="L244">				setState(16);</span>
<span class="fc" id="L245">				match(NOT);</span>
<span class="fc" id="L246">				setState(17);</span>
<span class="fc" id="L247">				expression(4);</span>
				}
<span class="fc" id="L249">				break;</span>
			case STRING:
			case FIELDTYPE:
				{
<span class="fc" id="L253">				_localctx = new AtomExpressionContext(_localctx);</span>
<span class="fc" id="L254">				_ctx = _localctx;</span>
<span class="fc" id="L255">				_prevctx = _localctx;</span>
<span class="fc" id="L256">				setState(18);</span>
<span class="fc" id="L257">				comparison();</span>
				}
<span class="fc" id="L259">				break;</span>
			default:
<span class="nc" id="L261">				throw new NoViableAltException(this);</span>
			}
<span class="fc" id="L263">			_ctx.stop = _input.LT(-1);</span>
<span class="fc" id="L264">			setState(29);</span>
<span class="fc" id="L265">			_errHandler.sync(this);</span>
<span class="fc" id="L266">			_alt = getInterpreter().adaptivePredict(_input,2,_ctx);</span>
<span class="pc bpc" id="L267" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">					if ( _parseListeners!=null ) triggerExitRuleEvent();</span>
<span class="fc" id="L270">					_prevctx = _localctx;</span>
					{
<span class="fc" id="L272">					setState(27);</span>
<span class="fc" id="L273">					_errHandler.sync(this);</span>
<span class="pc bpc" id="L274" title="1 of 3 branches missed.">					switch ( getInterpreter().adaptivePredict(_input,1,_ctx) ) {</span>
					case 1:
						{
<span class="fc" id="L277">						_localctx = new BinaryExpressionContext(new ExpressionContext(_parentctx, _parentState));</span>
<span class="fc" id="L278">						((BinaryExpressionContext)_localctx).left = _prevctx;</span>
<span class="fc" id="L279">						pushNewRecursionContext(_localctx, _startState, RULE_expression);</span>
<span class="fc" id="L280">						setState(21);</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 3))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 3)&quot;);</span>
<span class="fc" id="L282">						setState(22);</span>
<span class="fc" id="L283">						((BinaryExpressionContext)_localctx).operator = match(AND);</span>
<span class="fc" id="L284">						setState(23);</span>
<span class="fc" id="L285">						((BinaryExpressionContext)_localctx).right = expression(4);</span>
						}
<span class="fc" id="L287">						break;</span>
					case 2:
						{
<span class="fc" id="L290">						_localctx = new BinaryExpressionContext(new ExpressionContext(_parentctx, _parentState));</span>
<span class="fc" id="L291">						((BinaryExpressionContext)_localctx).left = _prevctx;</span>
<span class="fc" id="L292">						pushNewRecursionContext(_localctx, _startState, RULE_expression);</span>
<span class="fc" id="L293">						setState(24);</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 2))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 2)&quot;);</span>
<span class="fc" id="L295">						setState(25);</span>
<span class="fc" id="L296">						((BinaryExpressionContext)_localctx).operator = match(OR);</span>
<span class="fc" id="L297">						setState(26);</span>
<span class="fc" id="L298">						((BinaryExpressionContext)_localctx).right = expression(3);</span>
						}
						break;
					}
					} 
				}
<span class="fc" id="L304">				setState(31);</span>
<span class="fc" id="L305">				_errHandler.sync(this);</span>
<span class="fc" id="L306">				_alt = getInterpreter().adaptivePredict(_input,2,_ctx);</span>
			}
			}
		}
<span class="nc" id="L310">		catch (RecognitionException re) {</span>
<span class="nc" id="L311">			_localctx.exception = re;</span>
<span class="nc" id="L312">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L313">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L316">			unrollRecursionContexts(_parentctx);</span>
		}
<span class="fc" id="L318">		return _localctx;</span>
	}

	@SuppressWarnings(&quot;CheckReturnValue&quot;)
	public static class ComparisonContext extends ParserRuleContext {
		public NameContext left;
		public Token operator;
		public NameContext right;
		public List&lt;NameContext&gt; name() {
<span class="nc" id="L327">			return getRuleContexts(NameContext.class);</span>
		}
		public NameContext name(int i) {
<span class="nc" id="L330">			return getRuleContext(NameContext.class,i);</span>
		}
<span class="nc" id="L332">		public TerminalNode CONTAINS() { return getToken(SearchParser.CONTAINS, 0); }</span>
<span class="nc" id="L333">		public TerminalNode MATCHES() { return getToken(SearchParser.MATCHES, 0); }</span>
<span class="nc" id="L334">		public TerminalNode EQUAL() { return getToken(SearchParser.EQUAL, 0); }</span>
<span class="nc" id="L335">		public TerminalNode EEQUAL() { return getToken(SearchParser.EEQUAL, 0); }</span>
<span class="nc" id="L336">		public TerminalNode NEQUAL() { return getToken(SearchParser.NEQUAL, 0); }</span>
		public ComparisonContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L338">			super(parent, invokingState);</span>
<span class="fc" id="L339">		}</span>
<span class="nc" id="L340">		@Override public int getRuleIndex() { return RULE_comparison; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">			if ( visitor instanceof SearchVisitor ) return ((SearchVisitor&lt;? extends T&gt;)visitor).visitComparison(this);</span>
<span class="nc" id="L344">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ComparisonContext comparison() throws RecognitionException {
<span class="fc" id="L349">		ComparisonContext _localctx = new ComparisonContext(_ctx, getState());</span>
<span class="fc" id="L350">		enterRule(_localctx, 4, RULE_comparison);</span>
		int _la;
		try {
<span class="fc" id="L353">			setState(37);</span>
<span class="fc" id="L354">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L355" title="1 of 3 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,3,_ctx) ) {</span>
			case 1:
<span class="fc" id="L357">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L359">				setState(32);</span>
<span class="fc" id="L360">				((ComparisonContext)_localctx).left = name();</span>
<span class="fc" id="L361">				setState(33);</span>
<span class="fc" id="L362">				((ComparisonContext)_localctx).operator = _input.LT(1);</span>
<span class="fc" id="L363">				_la = _input.LA(1);</span>
<span class="pc bpc" id="L364" title="2 of 4 branches missed.">				if ( !((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; 1648L) != 0)) ) {</span>
<span class="nc" id="L365">					((ComparisonContext)_localctx).operator = (Token)_errHandler.recoverInline(this);</span>
				}
				else {
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</span>
<span class="fc" id="L369">					_errHandler.reportMatch(this);</span>
<span class="fc" id="L370">					consume();</span>
				}
<span class="fc" id="L372">				setState(34);</span>
<span class="fc" id="L373">				((ComparisonContext)_localctx).right = name();</span>
				}
<span class="fc" id="L375">				break;</span>
			case 2:
<span class="fc" id="L377">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L379">				setState(36);</span>
<span class="fc" id="L380">				((ComparisonContext)_localctx).right = name();</span>
				}
				break;
			}
		}
<span class="nc" id="L385">		catch (RecognitionException re) {</span>
<span class="nc" id="L386">			_localctx.exception = re;</span>
<span class="nc" id="L387">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L388">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L391">			exitRule();</span>
		}
<span class="fc" id="L393">		return _localctx;</span>
	}

	@SuppressWarnings(&quot;CheckReturnValue&quot;)
	public static class NameContext extends ParserRuleContext {
<span class="nc" id="L398">		public TerminalNode STRING() { return getToken(SearchParser.STRING, 0); }</span>
<span class="nc" id="L399">		public TerminalNode FIELDTYPE() { return getToken(SearchParser.FIELDTYPE, 0); }</span>
		public NameContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L401">			super(parent, invokingState);</span>
<span class="fc" id="L402">		}</span>
<span class="nc" id="L403">		@Override public int getRuleIndex() { return RULE_name; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="nc bnc" id="L406" title="All 2 branches missed.">			if ( visitor instanceof SearchVisitor ) return ((SearchVisitor&lt;? extends T&gt;)visitor).visitName(this);</span>
<span class="nc" id="L407">			else return visitor.visitChildren(this);</span>
		}
	}

	public final NameContext name() throws RecognitionException {
<span class="fc" id="L412">		NameContext _localctx = new NameContext(_ctx, getState());</span>
<span class="fc" id="L413">		enterRule(_localctx, 6, RULE_name);</span>
		int _la;
		try {
<span class="fc" id="L416">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L418">			setState(39);</span>
<span class="fc" id="L419">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L420" title="1 of 4 branches missed.">			if ( !(_la==STRING || _la==FIELDTYPE) ) {</span>
<span class="nc" id="L421">			_errHandler.recoverInline(this);</span>
			}
			else {
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</span>
<span class="fc" id="L425">				_errHandler.reportMatch(this);</span>
<span class="fc" id="L426">				consume();</span>
			}
			}
		}
<span class="nc" id="L430">		catch (RecognitionException re) {</span>
<span class="nc" id="L431">			_localctx.exception = re;</span>
<span class="nc" id="L432">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L433">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L436">			exitRule();</span>
		}
<span class="fc" id="L438">		return _localctx;</span>
	}

	public boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
<span class="nc bnc" id="L442" title="All 2 branches missed.">		switch (ruleIndex) {</span>
		case 1:
<span class="nc" id="L444">			return expression_sempred((ExpressionContext)_localctx, predIndex);</span>
		}
<span class="nc" id="L446">		return true;</span>
	}
	private boolean expression_sempred(ExpressionContext _localctx, int predIndex) {
<span class="nc bnc" id="L449" title="All 3 branches missed.">		switch (predIndex) {</span>
		case 0:
<span class="nc" id="L451">			return precpred(_ctx, 3);</span>
		case 1:
<span class="nc" id="L453">			return precpred(_ctx, 2);</span>
		}
<span class="nc" id="L455">		return true;</span>
	}

	public static final String _serializedATN =
		&quot;\u0004\u0001\u000e*\u0002\u0000\u0007\u0000\u0002\u0001\u0007\u0001\u0002&quot;+
		&quot;\u0002\u0007\u0002\u0002\u0003\u0007\u0003\u0001\u0000\u0001\u0000\u0001&quot;+
		&quot;\u0000\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001&quot;+
		&quot;\u0001\u0001\u0001\u0001\u0001\u0003\u0001\u0014\b\u0001\u0001\u0001\u0001&quot;+
		&quot;\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0005\u0001\u001c&quot;+
		&quot;\b\u0001\n\u0001\f\u0001\u001f\t\u0001\u0001\u0002\u0001\u0002\u0001\u0002&quot;+
		&quot;\u0001\u0002\u0001\u0002\u0003\u0002&amp;\b\u0002\u0001\u0003\u0001\u0003&quot;+
		&quot;\u0001\u0003\u0000\u0001\u0002\u0004\u0000\u0002\u0004\u0006\u0000\u0002&quot;+
		&quot;\u0002\u0000\u0004\u0006\t\n\u0002\u0000\f\f\u000e\u000e*\u0000\b\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0002\u0013\u0001\u0000\u0000\u0000\u0004%\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0006\'\u0001\u0000\u0000\u0000\b\t\u0003\u0002\u0001\u0000&quot;+
		&quot;\t\n\u0005\u0000\u0000\u0001\n\u0001\u0001\u0000\u0000\u0000\u000b\f\u0006&quot;+
		&quot;\u0001\uffff\uffff\u0000\f\r\u0005\u0002\u0000\u0000\r\u000e\u0003\u0002&quot;+
		&quot;\u0001\u0000\u000e\u000f\u0005\u0003\u0000\u0000\u000f\u0014\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0010\u0011\u0005\u000b\u0000\u0000\u0011\u0014\u0003\u0002&quot;+
		&quot;\u0001\u0004\u0012\u0014\u0003\u0004\u0002\u0000\u0013\u000b\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0013\u0010\u0001\u0000\u0000\u0000\u0013\u0012\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0014\u001d\u0001\u0000\u0000\u0000\u0015\u0016\n\u0003\u0000&quot;+
		&quot;\u0000\u0016\u0017\u0005\u0007\u0000\u0000\u0017\u001c\u0003\u0002\u0001&quot;+
		&quot;\u0004\u0018\u0019\n\u0002\u0000\u0000\u0019\u001a\u0005\b\u0000\u0000&quot;+
		&quot;\u001a\u001c\u0003\u0002\u0001\u0003\u001b\u0015\u0001\u0000\u0000\u0000&quot;+
		&quot;\u001b\u0018\u0001\u0000\u0000\u0000\u001c\u001f\u0001\u0000\u0000\u0000&quot;+
		&quot;\u001d\u001b\u0001\u0000\u0000\u0000\u001d\u001e\u0001\u0000\u0000\u0000&quot;+
		&quot;\u001e\u0003\u0001\u0000\u0000\u0000\u001f\u001d\u0001\u0000\u0000\u0000&quot;+
		&quot; !\u0003\u0006\u0003\u0000!\&quot;\u0007\u0000\u0000\u0000\&quot;#\u0003\u0006\u0003&quot;+
		&quot;\u0000#&amp;\u0001\u0000\u0000\u0000$&amp;\u0003\u0006\u0003\u0000% \u0001\u0000&quot;+
		&quot;\u0000\u0000%$\u0001\u0000\u0000\u0000&amp;\u0005\u0001\u0000\u0000\u0000&quot;+
		&quot;\'(\u0007\u0001\u0000\u0000(\u0007\u0001\u0000\u0000\u0000\u0004\u0013&quot;+
		&quot;\u001b\u001d%&quot;;
<span class="fc" id="L488">	public static final ATN _ATN =</span>
<span class="fc" id="L489">		new ATNDeserializer().deserialize(_serializedATN.toCharArray());</span>
	static {
<span class="fc" id="L491">		_decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">		for (int i = 0; i &lt; _ATN.getNumberOfDecisions(); i++) {</span>
<span class="fc" id="L493">			_decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);</span>
		}
<span class="fc" id="L495">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>